/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {
  Timestamp,
  Uint64,
  Uint128,
  Addr,
  Identifier,
  InstantiateMsg,
  ExecuteMsg,
  QueryMsg,
  ArrayOfOrdersResponse,
  OrdersResponse,
  OrderBookItem,
  Config,
  LockedAmountResponse,
  PositionResponse,
  PositionState,
  Settlement,
  Position,
} from "./KogenMarkets.types";
export interface KogenMarketsReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  bids: ({
    price,
    sender,
  }: {
    price?: Uint128;
    sender?: Addr;
  }) => Promise<ArrayOfOrdersResponse>;
  asks: ({
    price,
    sender,
  }: {
    price?: Uint128;
    sender?: Addr;
  }) => Promise<ArrayOfOrdersResponse>;
  lockedAmount: ({ owner }: { owner: Addr }) => Promise<LockedAmountResponse>;
  position: ({ owner }: { owner: Addr }) => Promise<PositionResponse>;
}
export class KogenMarketsQueryClient implements KogenMarketsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.bids = this.bids.bind(this);
    this.asks = this.asks.bind(this);
    this.lockedAmount = this.lockedAmount.bind(this);
    this.position = this.position.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    });
  };
  bids = async ({
    price,
    sender,
  }: {
    price?: Uint128;
    sender?: Addr;
  }): Promise<ArrayOfOrdersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bids: {
        price,
        sender,
      },
    });
  };
  asks = async ({
    price,
    sender,
  }: {
    price?: Uint128;
    sender?: Addr;
  }): Promise<ArrayOfOrdersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks: {
        price,
        sender,
      },
    });
  };
  lockedAmount = async ({
    owner,
  }: {
    owner: Addr;
  }): Promise<LockedAmountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      locked_amount: {
        owner,
      },
    });
  };
  position = async ({ owner }: { owner: Addr }): Promise<PositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        owner,
      },
    });
  };
}
export interface KogenMarketsInterface extends KogenMarketsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>;
  askOrder: (
    {
      price,
      quantity,
    }: {
      price: Uint128;
      quantity: Uint128;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>;
  bidOrder: (
    {
      price,
      quantity,
    }: {
      price: Uint128;
      quantity: Uint128;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>;
  exercise: (
    {
      expiryPrice,
    }: {
      expiryPrice?: Uint128;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>;
}
export class KogenMarketsClient
  extends KogenMarketsQueryClient
  implements KogenMarketsInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string,
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.askOrder = this.askOrder.bind(this);
    this.bidOrder = this.bidOrder.bind(this);
    this.exercise = this.exercise.bind(this);
  }

  updateConfig = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {},
      },
      fee,
      memo,
      _funds,
    );
  };
  askOrder = async (
    {
      price,
      quantity,
    }: {
      price: Uint128;
      quantity: Uint128;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        ask_order: {
          price,
          quantity,
        },
      },
      fee,
      memo,
      _funds,
    );
  };
  bidOrder = async (
    {
      price,
      quantity,
    }: {
      price: Uint128;
      quantity: Uint128;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        bid_order: {
          price,
          quantity,
        },
      },
      fee,
      memo,
      _funds,
    );
  };
  exercise = async (
    {
      expiryPrice,
    }: {
      expiryPrice?: Uint128;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        exercise: {
          expiry_price: expiryPrice,
        },
      },
      fee,
      memo,
      _funds,
    );
  };
}
